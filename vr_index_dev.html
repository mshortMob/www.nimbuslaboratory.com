<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js vr - cubes</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
        <style>
            body {
                margin: 0;
                background-color: #000;
                color: #fff;
                font-family: Monospace;
                font-size: 13px;
                line-height: 24px;
                overscroll-behavior: none;
            }

            a {
                color: #ff0;
                text-decoration: none;
            }

            a:hover {
                text-decoration: underline;
            }

            button {
                cursor: pointer;
                text-transform: uppercase;
            }

            #info {
                position: absolute;
                top: 0px;
                width: 100%;
                padding: 10px;
                box-sizing: border-box;
                text-align: center;
                -moz-user-select: none;
                -webkit-user-select: none;
                -ms-user-select: none;
                user-select: none;
                pointer-events: none;
                z-index: 1; /* TODO Solve this in HTML */
            }

            a, button, input, select {
                pointer-events: auto;
            }

            .dg.ac {
                -moz-user-select: none;
                -webkit-user-select: none;
                -ms-user-select: none;
                user-select: none;
                z-index: 2 !important; /* TODO Solve this in HTML */
            }

            #overlay {
                position: absolute;
                font-size: 16px;
                z-index: 2;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
                flex-direction: column;
                background: rgba(0,0,0,0.7);
            }

                #overlay button {
                    background: transparent;
                    border: 0;
                    border: 1px solid rgb(255, 255, 255);
                    border-radius: 4px;
                    color: #ffffff;
                    padding: 12px 18px;
                    text-transform: uppercase;
                    cursor: pointer;
                }

            #notSupported {
                width: 50%;
                margin: auto;
                background-color: #f00;
                margin-top: 20px;
                padding: 10px;
            }

        </style>
	</head>
	<body>
		<script type="module">
			import * as THREE from 'https://threejs.org/build/three.module.js';

			import { BoxLineGeometry } from 'https://threejs.org/examples/jsm/geometries/BoxLineGeometry.js';
			import { VRButton } from 'https://threejs.org/examples/jsm/webxr/VRButton.js';
			import { XRControllerModelFactory } from 'https://threejs.org/examples/jsm/webxr/XRControllerModelFactory.js';

			const clock = new THREE.Clock();
			let container;
			let camera, scene, raycaster, renderer;
			let room;
			let controller, controller2, controllerGrip, controllerGrip2;
			let colorIndex;
			let INTERSECTED;
			const tempMatrix = new THREE.Matrix4();

			init();
			animate();

			function init() {
				window.addEventListener("keypress", keyHandler);
				window.addEventListener("keyup", keyHandler);
				container = document.createElement( 'div' );
				document.body.appendChild( container );
				scene = new THREE.Scene();

				scene.fog = new THREE.Fog(0x000022, 10, 100);

				scene.add(createHemisphereMap());
				initCameraAndLights();
				raycaster = new THREE.Raycaster();
				initRenderer();
				initControllers();
				window.addEventListener( 'resize', onWindowResize );
				document.body.appendChild( VRButton.createButton( renderer ) );

				colorIndex=createColorIndex();
				addObject(0,0,0,false,1,"select");
			}

			function initRenderer(){
				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.outputEncoding = THREE.sRGBEncoding;
				renderer.xr.enabled = true;
				container.appendChild( renderer.domElement );
			}

			function initCameraAndLights(){
				camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.1, 100 );
				camera.position.set( 0, 1.6, 3);
				scene.add( camera );

				scene.add( new THREE.HemisphereLight( 0x606060, 0x404040 ) );
				const light = new THREE.DirectionalLight( 0xffffff );
				light.position.set( 1, 1, 1 ).normalize();
				scene.add( light );
			}

			function initControllers(){
				function onSelectStart() {
					this.userData.isSelecting = true;
				}
				function onSelectEnd() {
					this.userData.isSelecting = false;
				}
				function onSqueezeStart() {
					this.userData.isSqueezing = true;
				}
				function onSqueezeEnd() {
					this.userData.isSqueezing = false;
				}

				controller = renderer.xr.getController( 0 );
				controller.addEventListener( 'selectstart', onSelectStart );
				controller.addEventListener( 'selectend', onSelectEnd );
				controller.addEventListener( 'squeezestart', onSqueezeStart );
				controller.addEventListener( 'squeezeend', onSqueezeEnd );

				controller2 = renderer.xr.getController( 1 );
				controller2.addEventListener( 'selectstart', onSelectStart );
				controller2.addEventListener( 'selectend', onSelectEnd );
				controller2.addEventListener( 'squeezestart', onSqueezeStart );
				controller2.addEventListener( 'squeezeend', onSqueezeEnd );

				controller.addEventListener( 'connected', function ( event ) {
					this.add( buildController( event.data ) );
				} );
				controller.addEventListener( 'disconnected', function () {
					this.remove( this.children[ 0 ] );
				} );
				scene.add( controller );

				const controllerModelFactory = new XRControllerModelFactory();

				controllerGrip = renderer.xr.getControllerGrip( 0 );
				controllerGrip.add( controllerModelFactory.createControllerModel( controllerGrip ) );
				scene.add( controllerGrip );
				controllerGrip2 = renderer.xr.getControllerGrip( 1 );
				controllerGrip2.add( controllerModelFactory.createControllerModel( controllerGrip2 ) );
				scene.add( controllerGrip2 );
			}

			function createHemisphereMap(){
				var radius = 60;
				var radialSegments = 32;
				var hsmaterial = new THREE.MeshPhongMaterial({side: THREE.DoubleSide, map: new THREE.TextureLoader().load( 'assets/stars3.jpg' ), opacity: .34, transparent:true });
				var hemiSphereGeom = new THREE.SphereBufferGeometry(radius, radialSegments, Math.round(radialSegments / 4), 0, Math.PI * 2, 0, Math.PI * 0.5);
				var hemiSphere = new THREE.Mesh(hemiSphereGeom, hsmaterial);
				var capGeom = new THREE.CircleBufferGeometry(radius, radialSegments);
				capGeom.rotateX(Math.PI * 0.5);
				var hfmaterial = new THREE.MeshPhongMaterial({side: THREE.DoubleSide, map: new THREE.TextureLoader().load( 'assets/grass2.jpg' ),  bumpScale:1, bumpMap: new THREE.TextureLoader().load( 'assets/grass2.jpg' ), opacity: .11, transparent:true });
				hfmaterial.map.offset.set( 0, 0 );
				hfmaterial.map.repeat.set( 16, 16 );
				hfmaterial.map.wrapS=THREE.MirroredRepeatWrapping;
				hfmaterial.map.wrapT=THREE.MirroredRepeatWrapping;
				var cap = new THREE.Mesh(capGeom, hfmaterial);
				hemiSphere.add(cap);
				hemiSphere.position.y=-1.5;
				return hemiSphere;
			}

			function buildController( data ) {

				let geometry, material;

				switch ( data.targetRayMode ) {

					case 'tracked-pointer':

						geometry = new THREE.BufferGeometry();
						geometry.setAttribute( 'position', new THREE.Float32BufferAttribute( [ 0, 0, 0, 0, 0, - 1 ], 3 ) );
						geometry.setAttribute( 'color', new THREE.Float32BufferAttribute( [ 0.5, 0.5, 0.5, 0, 0, 0 ], 3 ) );

						material = new THREE.LineBasicMaterial( { vertexColors: true, blending: THREE.AdditiveBlending } );

						return new THREE.Line( geometry, material );

					case 'gaze':

						geometry = new THREE.RingGeometry( 0.02, 0.04, 32 ).translate( 0, 0, - 1 );
						material = new THREE.MeshBasicMaterial( { opacity: 0.5, transparent: true } );
						return new THREE.Mesh( geometry, material );

				}

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {
				renderer.setAnimationLoop( render );
			}
					
			function keyHandler(event){
				if(event.key=="s" && event.type=="keypress"){
					console.log("s down");
				}
				if(event.key=="s" && event.type=="keyup"){
					console.log("s up");
				}
			}
			
			function render() {
				if ( controller.userData.isSelecting === true ){
					addObject(0,0,0,false,1,"select");
				}
				if ( controller2.userData.isSelecting === true ){
					addObject(0,0,0,false,2,"select");
				}
				if ( controller.userData.isSqueezing === true ){
					addObject(0,0,0,false,1,"squeeze");
				}
				if ( controller2.userData.isSqueezing === true ){
					addObject(0,0,0,false,2,"squeeze");
				}
				for(var x=0; x<scene.children.length; x++){
					if(scene.children[x].class=="object"){
						scene.children[x].update();
					}
				}
				renderer.render( scene, camera );
			}

			function rgbToHex(r, g, b) {
                    r=parseInt(r);
                    g=parseInt(g);
                    b=parseInt(b);
                    function componentToHex(c) {
                        var hex = c.toString(16);
                        return hex.length == 1 ? "0" + hex : hex;
                    }
                    return "#" + componentToHex(r) + componentToHex(g) + componentToHex(b);
            }

            function createSpriteSphere(){
				const radius = .5;

                var xList=[];
                var yList=[];
                var zList=[];
                var rList=[];
                var gList=[];
                var bList=[];
                for(var x=0; x<amount; x++){
                    for(var y=0; y<amount; y++){
                        for(var z=0; z<amount; z++){
                            xList.push((x/amount)-.5);
                            yList.push((y/amount)-.5);
                            zList.push((z/amount)-.5);
                            rList.push((x/amount)*255);
                            gList.push((y/amount)*255);
                            bList.push((z/amount)*255);
                        }
                    }
                }
                // console.log(gList);

				group = new THREE.Group();
                var spriteTexture1=new THREE.TextureLoader().load( "sprites/sprite1.png" );
				var spriteTexture2=new THREE.TextureLoader().load( "sprites/sprite2.png" );
				var spriteTexture3=new THREE.TextureLoader().load( "sprites/sprite3.png" );
				var spriteTextures=[spriteTexture1, spriteTexture2, spriteTexture3];
				for ( let a = 0; a < amount*amount*amount; a ++ ) {                    
					var material = new THREE.SpriteMaterial( { map: spriteTextures[a%3], color: rgbToHex(rList[a],gList[a],bList[a]), fog: true, blending: THREE.AdditiveBlending, depthTest: false, transparent: true } );

					const x = xList[a];
					const y = yList[a];
					const z = zList[a];

					var sprite = new THREE.Sprite( material );
					sprite.position.set( x,y,z );
					sprite.position.normalize();
					sprite.position.multiplyScalar( radius );
                    sprite.scale.set( .2, .2, .2 );
					group.position.y=2;
					group.position.z=-1;
					group.triggerTime=new Date().getTime();
					group.alpha=1;
					group.add( sprite );
				}
				return group;
            }

			function createColorIndex(){
				var rList=[];
				for(var x=0; x<255; x=x+10){
					rList.push(x);
				}

				for(var x=255; x>0; x=x-10){
					rList.push(x);
				}
				for(var x=0; x<255; x=x+10){
					rList.push(0);
				}
				// console.log(rList);

				var gList=[];
				for(var x=0; x<255; x=x+10){
					gList.push(0);
				}
				for(var x=0; x<255; x=x+10){
					gList.push(x);
				}
				for(var x=255; x>0; x=x-10){
					gList.push(x);
				}
				// console.log(gList);


				var bList=[];
				for(var x=255; x>0; x=x-10){
					bList.push(x);
				}
				for(var x=0; x<255; x=x+10){
					bList.push(0);
				}

				for(var x=0; x<255; x=x+10){
					bList.push(x);
				}

				var colorIndex=[];
				for(var x=0; x<rList.length; x=x+1){
					colorIndex.push({"r":rList[x], "g":gList[x], "b":bList[x]});
				}
				// setInterval(function(){
				// 	console.log(colorIndex[ parseInt(new Date().getTime()/200)%colorIndex.length]);
				// },50)
				return(colorIndex);
			}

			function addObject(x,y,z,isMirror,controllerNumber,button){

				var mesh=init();

				function init(){
					if(button=="squeeze"){
						var radius=.5;
						var material = new THREE.MeshPhongMaterial( {color: rgbToHex(colorIndex[ parseInt(new Date().getTime()/200)%colorIndex.length].r, colorIndex[ parseInt(new Date().getTime()/200)%colorIndex.length].g, colorIndex[ parseInt(new Date().getTime()/200)%colorIndex.length].b)} );
					}else{
						var radius=.19;
						var material = new THREE.MeshPhongMaterial( {color: rgbToHex(colorIndex[ parseInt(new Date().getTime()/50)%colorIndex.length].r, colorIndex[ parseInt(new Date().getTime()/50)%colorIndex.length].g, colorIndex[ parseInt(new Date().getTime()/50)%colorIndex.length].b)} );
					}
					var geometry = new THREE.SphereGeometry( radius, 44, 44 );
					var mesh = new THREE.Mesh( geometry, material );
					mesh.class="object";
					mesh.lifetime=4000;
					mesh.createTime=new Date().getTime();
					mesh.velocity=new THREE.Vector3();
					if(button=="squeeze"){
						mesh.velocity.set(0,0,.005);
						mesh.lifetime=6000;
					}else{
						mesh.velocity.set(0,0,.015);
						mesh.lifetime=6000;
					}
					return mesh;

				}

				mesh.update=function(){
					if( Math.abs(this.createTime-(new Date().getTime())) > this.lifetime ){
							scene.remove(this);
							this.geometry.dispose();
							this.material.dispose();
					}else{
						this.position.x+=this.velocity.x;
						this.position.y+=this.velocity.y;
						this.position.z+=this.velocity.z;
					}
				}

				mesh.setInitialPositionWithMirroring=function(){
					if(x==0 && y==0 && z==0 && isMirror==false){
						if(controllerNumber==1){
							mesh.position.copy( controller.position );
							mesh.position.z=(mesh.position.z*20)+.25;
							mesh.position.x=(mesh.position.x*12);
							mesh.position.y=(mesh.position.y*12)-6.25;
						}
						if(controllerNumber==2){
							mesh.position.copy( controller2.position );
							mesh.position.z=(mesh.position.z*20)+.25;
							mesh.position.x=(mesh.position.x*12);
							mesh.position.y=(mesh.position.y*12)-6.25;							
						}
						addObject(mesh.position.x,mesh.position.y,mesh.position.z,true,controllerNumber,button)
					}else{
						mesh.position.set(-x,y,z);
					}
					if(window.location.href.indexOf("localhost")!=-1){
						mesh.position.set(0,1,-10.5);
					}
				}

				mesh.setInitialPositionWithMirroring();
				scene.add(mesh);
			}

		</script>
	</body>
</html>
