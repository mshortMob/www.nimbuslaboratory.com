<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js vr - cubes</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
        <style>
            body {
                margin: 0;
                background-color: #000;
                color: #fff;
                font-family: Monospace;
                font-size: 13px;
                line-height: 24px;
                overscroll-behavior: none;
            }

            a {
                color: #ff0;
                text-decoration: none;
            }

            a:hover {
                text-decoration: underline;
            }

            button {
                cursor: pointer;
                text-transform: uppercase;
            }

            #info {
                position: absolute;
                top: 0px;
                width: 100%;
                padding: 10px;
                box-sizing: border-box;
                text-align: center;
                -moz-user-select: none;
                -webkit-user-select: none;
                -ms-user-select: none;
                user-select: none;
                pointer-events: none;
                z-index: 1; /* TODO Solve this in HTML */
            }

            a, button, input, select {
                pointer-events: auto;
            }

            .dg.ac {
                -moz-user-select: none;
                -webkit-user-select: none;
                -ms-user-select: none;
                user-select: none;
                z-index: 2 !important; /* TODO Solve this in HTML */
            }

            #overlay {
                position: absolute;
                font-size: 16px;
                z-index: 2;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
                flex-direction: column;
                background: rgba(0,0,0,0.7);
            }

                #overlay button {
                    background: transparent;
                    border: 0;
                    border: 1px solid rgb(255, 255, 255);
                    border-radius: 4px;
                    color: #ffffff;
                    padding: 12px 18px;
                    text-transform: uppercase;
                    cursor: pointer;
                }

            #notSupported {
                width: 50%;
                margin: auto;
                background-color: #f00;
                margin-top: 20px;
                padding: 10px;
            }

        </style>
	</head>
	<body>
		<script type="module">
			import * as THREE from 'https://threejs.org/build/three.module.js';

			import { BoxLineGeometry } from 'https://threejs.org/examples/jsm/geometries/BoxLineGeometry.js';
			import { VRButton } from 'https://threejs.org/examples/jsm/webxr/VRButton.js';
			import { XRControllerModelFactory } from 'https://threejs.org/examples/jsm/webxr/XRControllerModelFactory.js';

			const clock = new THREE.Clock();
			let container;
			let camera, scene, raycaster, renderer, user;
			let room;
			let controlsGroup;
			let controller, controller2, controllerGrip, controllerGrip2;
			let colorIndex;
			let INTERSECTED;
			var yOffeset=0;
			const tempMatrix = new THREE.Matrix4();

			init();
			animate();

			function init() {
				window.addEventListener("keypress", keyHandler);
				window.addEventListener("keyup", keyHandler);
				container = document.createElement( 'div' );
				document.body.appendChild( container );
				scene = new THREE.Scene();
				// scene.fog = new THREE.Fog(0x000000, 0, 65);
				scene.add(createHemisphereMap());
				// addBackgroundSprites();
				// planeBufferTest();
				addControlPanel();
				initCameraAndLights();
				raycaster = new THREE.Raycaster();
				initRenderer();
				initControllers();
				window.addEventListener( 'resize', onWindowResize );
				document.body.appendChild( VRButton.createButton( renderer ) );

				colorIndex=createColorIndex();
				addObject(0,0,0,false,1,"select2");
			}

			function planeBufferTest(){
				const geometry = new THREE.BufferGeometry();
				const indices = [];
				const vertices = [];
				const normals = [];
				const colors = [];
				const size = 1000;
				const segments = 50;
				const halfSize = size / 2;
				const segmentSize = size / segments;

				// generate vertices, normals and color data for a simple grid geometry
				for ( let i = 0; i <= segments; i ++ ) {
					const y = ( i * segmentSize ) - halfSize;
					for ( let j = 0; j <= segments; j ++ ) {
						const x = ( j * segmentSize ) - halfSize;
						vertices.push( x, - y, 1.*Math.random() );
						normals.push( 0, 0, 1 );
						const r = ( x / size ) + 0.5;
						const g = ( y / size ) + 0.5;
						colors.push( r, g, 1 );
					}

				}

				// generate indices (data for element array buffer)
				for ( let i = 0; i < segments; i ++ ) {
					for ( let j = 0; j < segments; j ++ ) {
						const a = i * ( segments + 1 ) + ( j + 1 );
						const b = i * ( segments + 1 ) + j;
						const c = ( i + 1 ) * ( segments + 1 ) + j;
						const d = ( i + 1 ) * ( segments + 1 ) + ( j + 1 );
						// generate two faces (triangles) per iteration
						indices.push( a, b, d ); // face one
						indices.push( b, c, d ); // face two
					}
				}

				geometry.setIndex( indices );
				geometry.setAttribute( 'position', new THREE.Float32BufferAttribute( vertices, 3 ) );
				geometry.setAttribute( 'normal', new THREE.Float32BufferAttribute( normals, 3 ) );
				geometry.setAttribute( 'color', new THREE.Float32BufferAttribute( colors, 3 ) );

				// const material = new THREE.MeshPhongMaterial( {
				// 	side: THREE.DoubleSide,
				// 	vertexColors: true
				// } );
				var material = new THREE.MeshPhongMaterial({side: THREE.DoubleSide, map: new THREE.TextureLoader().load( 'assets/grass2.jpg' ), opacity: .45, transparent:true, fog: true });
				material.map.offset.set( 0, 0 );
				material.map.repeat.set( 16, 16 );
				material.map.wrapS=THREE.MirroredRepeatWrapping;
				material.map.wrapT=THREE.MirroredRepeatWrapping;

				var mesh = new THREE.Mesh( geometry, material );
				mesh.position.set(0,0,-2)
				mesh.rotateX(Math.PI * 0.5);

				scene.add( mesh );
			}
			
			function initRenderer(){
				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.outputEncoding = THREE.sRGBEncoding;
				renderer.xr.enabled = true;
				container.appendChild( renderer.domElement );
			}

			function initCameraAndLights(){
				user = new THREE.Group();
				user.position.set(0,0,0);
				camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.1, 100 );
				camera.position.set( 0, 1.6, 3);
				user.add( camera );
				scene.add( user );

				scene.add( new THREE.HemisphereLight( 0x606060, 0x404040 ) );
				const light = new THREE.DirectionalLight( 0xffffff );
				light.position.set( 1, 1, 1 ).normalize();
				scene.add( light );

				console.log(camera.getWorldQuaternion())
			}

			function initControllers(){
				function onSelectStart() {
					this.userData.isSelecting = true;
				}
				function onSelectEnd() {
					this.userData.isSelecting = false;
				}
				function onSqueezeStart() {
					this.userData.isSqueezing = true;
				}
				function onSqueezeEnd() {
					this.userData.isSqueezing = false;
				}

				controller = renderer.xr.getController( 0 );
				controller.addEventListener( 'selectstart', onSelectStart );
				controller.addEventListener( 'selectend', onSelectEnd );
				controller.addEventListener( 'squeezestart', onSqueezeStart );
				controller.addEventListener( 'squeezeend', onSqueezeEnd );

				controller2 = renderer.xr.getController( 1 );
				controller2.addEventListener( 'selectstart', onSelectStart );
				controller2.addEventListener( 'selectend', onSelectEnd );
				controller2.addEventListener( 'squeezestart', onSqueezeStart );
				controller2.addEventListener( 'squeezeend', onSqueezeEnd );

				controller.addEventListener( 'connected', function ( event ) {
					this.add( buildController( event.data ) );
				} );
				controller.addEventListener( 'disconnected', function () {
					this.remove( this.children[ 0 ] );
				} );
				scene.add( controller );

				const controllerModelFactory = new XRControllerModelFactory();

				controllerGrip = renderer.xr.getControllerGrip( 0 );
				controllerGrip.add( controllerModelFactory.createControllerModel( controllerGrip ) );
				scene.add( controllerGrip );
				controllerGrip2 = renderer.xr.getControllerGrip( 1 );
				controllerGrip2.add( controllerModelFactory.createControllerModel( controllerGrip2 ) );
				scene.add( controllerGrip2 );
			}

			function addControlPanel(){

				function addPlaneButton(x,y,w,h,color,name){
					var geometry = new THREE.PlaneGeometry( w, h );
					var material = new THREE.MeshBasicMaterial( {color: color, side: THREE.DoubleSide} );
					var plane = new THREE.Mesh( geometry, material );
					plane.position.set(x,y,-2);
					plane.name=name;
					plane.onSelect=function(INTERSECTED){
						if ( controller.userData.isSelecting === true ){
							if(this.name=="pattern1"){
							user.rotation.y-=.005;
							}
							if(this.name=="pattern2"){
								user.rotation.y+=.005;
							}
							if(this.name=="pattern3"){
								yOffeset+=.005;
							}
							if(this.name=="pattern4"){
								yOffeset-=.005;
							}
						}
						for(var x=0; x<controlsGroup.children.length; x++){
							controlsGroup.children[x].material.color={"r":.13, "g":.13, "b":.13}
						}
						INTERSECTED.material.color={"r":.05, "g":.05, "b":.3};
					}
					plane.onDeselect=function(INTERSECTED){
						INTERSECTED.material.color={"r":.13, "g":.13, "b":.13}
					}
					return plane;
				}

				controlsGroup=new THREE.Group();
				controlsGroup.add( addPlaneButton(.6,1,.5,.5,0x222222,"pattern1") );
				controlsGroup.add( addPlaneButton(-.6,1,.5,.5,0x222222,"pattern2") );
				controlsGroup.add( addPlaneButton(0,1.6,.5,.5,0x222222,"pattern3") );
				controlsGroup.add( addPlaneButton(0,.4,.5,.5,0x222222,"pattern4") );

				controlsGroup.rotateX(6.28/4);
				controlsGroup.position.y=-2.5;
				controlsGroup.position.z=-3.5;
				controlsGroup.scale.set(.5,.5,.5);
				scene.add(controlsGroup);
			}
			
			function createHemisphereMap(){
				var radius = 60;
				var radialSegments = 32;
				var hsmaterial = new THREE.MeshPhongMaterial({side: THREE.DoubleSide, map: new THREE.TextureLoader().load( 'assets/stars3.jpg' ), opacity: .34, transparent:true, fog: true });
				var hemiSphereGeom = new THREE.SphereBufferGeometry(radius, radialSegments, Math.round(radialSegments / 4), 0, Math.PI * 2, 0, Math.PI * 0.5);
				var hemiSphere = new THREE.Mesh(hemiSphereGeom, hsmaterial);
				var capGeom = new THREE.CircleBufferGeometry(radius, radialSegments);
				capGeom.rotateX(Math.PI * 0.5);
				var hfmaterial = new THREE.MeshPhongMaterial({side: THREE.DoubleSide, map: new THREE.TextureLoader().load( 'assets/grass2.jpg' ),  bumpScale:1, bumpMap: new THREE.TextureLoader().load( 'assets/grass2.jpg' ), opacity: .095, transparent:true, fog: true });
				hfmaterial.map.offset.set( 0, 0 );
				hfmaterial.map.repeat.set( 16, 16 );
				hfmaterial.map.wrapS=THREE.MirroredRepeatWrapping;
				hfmaterial.map.wrapT=THREE.MirroredRepeatWrapping;
				var cap = new THREE.Mesh(capGeom, hfmaterial);
				hemiSphere.add(cap);
				hemiSphere.position.y=-1.5;
				return hemiSphere;
			}

			function addBackgroundSprites(){
				var geometry = new THREE.BufferGeometry();
				var vertices = [];
				var materials = [];

				var textureLoader = new THREE.TextureLoader();

				var sprite1 = textureLoader.load( 'sprites/sprite2.png' );
				var sprite2 = textureLoader.load( 'sprites/sprite2.png' );
				var sprite3 = textureLoader.load( 'sprites/sprite3.png' );

				for ( var i = 0; i < 10000; i ++ ) {

					var x = Math.random() * 1000 - 500;
					var y = Math.random() * 1000 - 500;
					var z = Math.random() * 1000 - 500;

					vertices.push( x, y, z );

				}

				geometry.setAttribute( 'position', new THREE.Float32BufferAttribute( vertices, 3 ) );

				var parameters = [
					[[ 1.0, 1.0, 1.0 ], sprite1, 30 ],
					[[ .5, 0.9, 1.0 ], sprite2, 20 ],
					[[ .6, 1.0, 0.5 ], sprite3, 25 ]
				];

				for ( var i = 0; i < parameters.length; i ++ ) {

					var color = parameters[ i ][ 0 ];
					var sprite = parameters[ i ][ 1 ];
					var size = parameters[ i ][ 2 ];

					materials[ i ] = new THREE.PointsMaterial( { size: size, map: sprite, blending: THREE.AdditiveBlending, depthTest: false, transparent: true } );
					materials[ i ].color.setHSL( color[ 0 ], color[ 1 ], color[ 2 ] );

					var particles = new THREE.Points( geometry, materials[ i ] );

					particles.rotation.x = Math.random() * 6;
					particles.rotation.y = Math.random() * 6;
					particles.rotation.z = Math.random() * 6;
					particles.class="backgroundParticles";
					particles.update=function(){
						var time = Date.now() * 0.00005;
						this.rotation.x = time/7 * ( i < 4 ? i + 1 : - ( i + 1 ) );
						this.rotation.y = time/7 * ( i < 4 ? i + 1 : - ( i + 1 ) );
					}

					scene.add( particles );

				}
			}
			
			function buildController( data ) {

				let geometry, material;

				switch ( data.targetRayMode ) {

					case 'tracked-pointer':

						geometry = new THREE.BufferGeometry();
						geometry.setAttribute( 'position', new THREE.Float32BufferAttribute( [ 0, 0, 0, 0, 0, - 1 ], 3 ) );
						geometry.setAttribute( 'color', new THREE.Float32BufferAttribute( [ 0.5, 0.5, 0.5, 0, 0, 0 ], 3 ) );

						material = new THREE.LineBasicMaterial( { vertexColors: true, blending: THREE.AdditiveBlending } );

						return new THREE.Line( geometry, material );

					case 'gaze':

						geometry = new THREE.RingGeometry( 0.02, 0.04, 32 ).translate( 0, 0, - 1 );
						material = new THREE.MeshBasicMaterial( { opacity: 0.5, transparent: true } );
						return new THREE.Mesh( geometry, material );

				}

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {
				renderer.setAnimationLoop( render );
			}
					
			function keyHandler(event){
				if(event.key=="s" && event.type=="keypress"){
					console.log("s down");
				}
				if(event.key=="s" && event.type=="keyup"){
					console.log("s up");
				}
			}
			
			function calculateIntersects(){
				tempMatrix.identity().extractRotation( controller.matrixWorld )
				raycaster.ray.origin.setFromMatrixPosition( controller.matrixWorld );
				raycaster.ray.direction.set( 0, 0, - 1 ).applyMatrix4( tempMatrix );

				const intersects = raycaster.intersectObjects( controlsGroup.children );
				if ( intersects.length > 0 ) {
					// if ( INTERSECTED != intersects[ 0 ].object ) {
						// if ( INTERSECTED ) INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex );
						INTERSECTED = intersects[ 0 ].object;
						INTERSECTED.onSelect(INTERSECTED);
					// }
				} else {
					if(INTERSECTED!=undefined){
						INTERSECTED.onDeselect(INTERSECTED)
					}
					INTERSECTED = undefined;
				}
			}
			
			function render() {

				calculateIntersects();

				if ( controller.userData.isSelecting === true ){
					addObject(0,0,0,false,1,"select1");
				}
				if ( controller2.userData.isSelecting === true ){
					addObject(0,0,0,false,2,"select2");
				}
				if ( controller.userData.isSqueezing === true ){
					addObject(0,0,0,false,1,"squeeze1");
				}
				if ( controller2.userData.isSqueezing === true ){
					addObject(0,0,0,false,2,"squeeze2");
				}
				for(var x=0; x<scene.children.length; x++){
					if(scene.children[x].class=="object" || scene.children[x].class=="backgroundParticles"){
						scene.children[x].update();
					}
				}
				// camera.rotateY(.001);
				renderer.render( scene, camera );
			}

			function rgbToHex(r, g, b) {
                    r=parseInt(r);
                    g=parseInt(g);
                    b=parseInt(b);
                    function componentToHex(c) {
                        var hex = c.toString(16);
                        return hex.length == 1 ? "0" + hex : hex;
                    }
                    return "#" + componentToHex(r) + componentToHex(g) + componentToHex(b);
            }

            function createSpriteSphere(){
				const radius = .5;

                var xList=[];
                var yList=[];
                var zList=[];
                var rList=[];
                var gList=[];
                var bList=[];
                for(var x=0; x<amount; x++){
                    for(var y=0; y<amount; y++){
                        for(var z=0; z<amount; z++){
                            xList.push((x/amount)-.5);
                            yList.push((y/amount)-.5);
                            zList.push((z/amount)-.5);
                            rList.push((x/amount)*255);
                            gList.push((y/amount)*255);
                            bList.push((z/amount)*255);
                        }
                    }
                }
                // console.log(gList);

				group = new THREE.Group();
                var spriteTexture1=new THREE.TextureLoader().load( "sprites/sprite1.png" );
				var spriteTexture2=new THREE.TextureLoader().load( "sprites/sprite2.png" );
				var spriteTexture3=new THREE.TextureLoader().load( "sprites/sprite3.png" );
				var spriteTextures=[spriteTexture1, spriteTexture2, spriteTexture3];
				for ( let a = 0; a < amount*amount*amount; a ++ ) {                    
					var material = new THREE.SpriteMaterial( { map: spriteTextures[a%3], color: rgbToHex(rList[a],gList[a],bList[a]), fog: true, blending: THREE.AdditiveBlending, depthTest: false, transparent: true } );

					const x = xList[a];
					const y = yList[a];
					const z = zList[a];

					var sprite = new THREE.Sprite( material );
					sprite.position.set( x,y,z );
					sprite.position.normalize();
					sprite.position.multiplyScalar( radius );
                    sprite.scale.set( .2, .2, .2 );
					group.position.y=2;
					group.position.z=-1;
					group.triggerTime=new Date().getTime();
					group.alpha=1;
					group.add( sprite );
				}
				return group;
            }

			function createColorIndex(){
				var rList=[];
				for(var x=0; x<255; x=x+10){
					rList.push(x);
				}

				for(var x=255; x>0; x=x-10){
					rList.push(x);
				}
				for(var x=0; x<255; x=x+10){
					rList.push(0);
				}
				// console.log(rList);

				var gList=[];
				for(var x=0; x<255; x=x+10){
					gList.push(0);
				}
				for(var x=0; x<255; x=x+10){
					gList.push(x);
				}
				for(var x=255; x>0; x=x-10){
					gList.push(x);
				}
				// console.log(gList);


				var bList=[];
				for(var x=255; x>0; x=x-10){
					bList.push(x);
				}
				for(var x=0; x<255; x=x+10){
					bList.push(0);
				}

				for(var x=0; x<255; x=x+10){
					bList.push(x);
				}

				var colorIndex=[];
				for(var x=0; x<rList.length; x=x+1){
					colorIndex.push({"r":rList[x], "g":gList[x], "b":bList[x]});
				}
				// setInterval(function(){
				// 	console.log(colorIndex[ parseInt(new Date().getTime()/200)%colorIndex.length]);
				// },50)
				return(colorIndex);
			}

			function addObject(x,y,z,isMirror,controllerNumber,button){

				var mesh=init();

				function init(){
					if(button=="squeeze2"){
						var radius=.5;
						var material = new THREE.MeshPhongMaterial( {color: rgbToHex(colorIndex[ parseInt(new Date().getTime()/200)%colorIndex.length].r, colorIndex[ parseInt(new Date().getTime()/200)%colorIndex.length].g, colorIndex[ parseInt(new Date().getTime()/200)%colorIndex.length].b)} );
						var geometry = new THREE.SphereGeometry( radius, 44, 44 );
						var mesh = new THREE.Mesh( geometry, material );
						mesh.class="object";
						mesh.createTime=new Date().getTime();	
						mesh.velocity=new THREE.Vector3();
						mesh.velocity.set(0,0,.004);
						mesh.lifetime=7000;				
					}else if(button=="squeeze1"){
               			// var spriteTexture=new THREE.TextureLoader().load( "sprites/sprite1.png" );                
						// var material = new THREE.SpriteMaterial( { map: spriteTexture, fog: true, blending: THREE.AdditiveBlending, depthTest: false, transparent: true, color: rgbToHex(colorIndex[ parseInt(new Date().getTime()/25)%colorIndex.length].r, colorIndex[ parseInt(new Date().getTime()/25)%colorIndex.length].g, colorIndex[ parseInt(new Date().getTime()/25)%colorIndex.length].b) } );
						// var mesh = new THREE.Sprite( material );
						var radius=.5;
						var material = new THREE.MeshPhongMaterial( {color: rgbToHex(colorIndex[ parseInt(new Date().getTime()/400)%colorIndex.length].r, colorIndex[ parseInt(new Date().getTime()/400)%colorIndex.length].g, colorIndex[ parseInt(new Date().getTime()/400)%colorIndex.length].b)} );
						var geometry = new THREE.BoxGeometry( radius*2, radius*2, radius*2 );
						var mesh = new THREE.Mesh( geometry, material );
						mesh.rotateX((new Date().getTime()/400)%6.28)
						mesh.rotateY((new Date().getTime()/800)%6.28)
						mesh.class="object";
						mesh.createTime=new Date().getTime();
						mesh.velocity=new THREE.Vector3();
						mesh.velocity.set(0,0,.0088);
						mesh.lifetime=6000;
					}else if(button=="select2"){
						var radius=.19;
						var material = new THREE.MeshPhongMaterial( {color: rgbToHex(colorIndex[ parseInt(new Date().getTime()/100)%colorIndex.length].r, colorIndex[ parseInt(new Date().getTime()/100)%colorIndex.length].g, colorIndex[ parseInt(new Date().getTime()/100)%colorIndex.length].b)} );
						var geometry = new THREE.SphereGeometry( radius, 44, 44 );
						var mesh = new THREE.Mesh( geometry, material );
						mesh.class="object";
						mesh.createTime=new Date().getTime();
						mesh.velocity=new THREE.Vector3();
						mesh.velocity.set(0,0,.015);
						mesh.lifetime=6500;
					}else if(button=="select1"){
						var radius=.19;
						var material = new THREE.MeshPhongMaterial( {color: rgbToHex(colorIndex[ parseInt(new Date().getTime()/150)%colorIndex.length].r, colorIndex[ parseInt(new Date().getTime()/150)%colorIndex.length].g, colorIndex[ parseInt(new Date().getTime()/150)%colorIndex.length].b)} );
						var geometry = new THREE.BoxGeometry( radius*2, radius*2, radius*2 );
						var mesh = new THREE.Mesh( geometry, material );
						mesh.rotateX((new Date().getTime()/300)%6.28)
						mesh.rotateY((new Date().getTime()/600)%6.28)
						mesh.class="object";
						mesh.createTime=new Date().getTime();
						mesh.velocity=new THREE.Vector3();
						mesh.velocity.set(0,0,.03);
						mesh.lifetime=4000;
					}
					return mesh;
				}

				mesh.update=function(){
					if( Math.abs(this.createTime-(new Date().getTime())) > this.lifetime ){
							scene.remove(this);
							this.geometry.dispose();
							this.material.dispose();
					}else{
						this.position.x+=this.velocity.x;
						this.position.y+=this.velocity.y;
						this.position.z+=this.velocity.z;
					}
				}

				mesh.setInitialPositionWithMirroring=function(){
					if(x==0 && y==0 && z==0 && isMirror==false){
						if(controllerNumber==1){
							mesh.position.copy( controller.position );
							mesh.position.z=(mesh.position.z*20)+.25;
							mesh.position.x=(mesh.position.x*12);
							mesh.position.y=(mesh.position.y*12)-6.25+yOffeset;
						}
						if(controllerNumber==2){
							mesh.position.copy( controller2.position );
							mesh.position.z=(mesh.position.z*20)+.25;
							mesh.position.x=(mesh.position.x*12);
							mesh.position.y=(mesh.position.y*12)-6.25+yOffeset;							
						}
						addObject(mesh.position.x,mesh.position.y,mesh.position.z,true,controllerNumber,button)
					}else{
						mesh.position.set(-x,y,z);
					}
					if(window.location.href.indexOf("localhost")!=-1){
						mesh.position.set(0,1,-10.5);
					}
				}

				mesh.setInitialPositionWithMirroring();
				scene.add(mesh);
			}

		</script>
	</body>
</html>
